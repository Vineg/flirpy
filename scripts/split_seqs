#!/usr/bin/env python

import flirpy.io.seq
from flirpy.util.exiftool import Exiftool
import glob
import argparse
import os
import logging
import natsort
#import cv2
import shutil
from tqdm import tqdm
import time

def add_bool_arg(parser, name, help_string="", default=False):
    # https://stackoverflow.com/a/31347222
    group = parser.add_mutually_exclusive_group(required=False)
    group.add_argument('--' + name, dest=name, help=help_string, action='store_true')
    group.add_argument('--no_' + name, dest=name, help=help_string, action='store_false')
    parser.set_defaults(**{name:default})

def recursive_copy(src, dst):

    items = os.listdir(src)

    for item in items:

        item_path = os.path.join(src, item)
        new_dst = os.path.abspath(os.path.join(dst, item))

        if os.path.isfile(item_path):
            shutil.copy(item_path, new_dst)

        elif os.path.isdir(item_path):
            os.makedirs(new_dst, exist_ok=True)
            recursive_copy(item_path, new_dst)
    
    return

def recursive_move(src, dst):
    # https://stackoverflow.com/a/7420617/395457

    for src_dir, dirs, files in os.walk(src):
        dst_dir = src_dir.replace(src, dst, 1)
        
        os.makedirs(dst_dir, exist_ok=True)

        for file_ in files:
            src_file = os.path.join(src_dir, file_)
            dst_file = os.path.join(dst_dir, file_)
            if os.path.exists(dst_file):
                # in case of the src and dst are the same file
                if os.path.samefile(src_file, dst_file):
                    continue
                os.remove(dst_file)
            shutil.move(src_file, dst_dir)

if __name__ == "__main__":
    
    parser = argparse.ArgumentParser(description='Split all files in folder')
    parser.add_argument('-o', '--output', help='Output folder', default="./")
    parser.add_argument('-i', '--input', help='Input file mask, e.g. "/path/*.SEQ" ', default="*.SEQ")
    parser.add_argument('-v', '--verbosity', help='Logging level', default='info')
    parser.add_argument('--preview_format', help='Output preview format (png, jpg, tiff)', default='jpg')
    parser.add_argument('--width', help='Thermal image width', type=int, default=640)
    parser.add_argument('--height', help='Thermal image height', type=int, default=512)

    add_bool_arg(parser, name='merge_folders', help_string='Merge output folders (and remove intermediates afterwards)', default=True)
    add_bool_arg(parser, name='split_filetypes', help_string='Split output files by type (make raw/preview/radiometric folders)', default=True)
    add_bool_arg(parser, name='export_meta', help_string='Export meta information files (also for geotagging)', default=True)
    add_bool_arg(parser, name='export_tiff', help_string='Export radiometric tiff files', default=True)
    add_bool_arg(parser, name='export_preview', help_string='Export 8-bit preview png files', default=True)
    add_bool_arg(parser, name='skip_thermal', help_string='Skip thermal processing', default=False)
    add_bool_arg(parser, name='sync_rgb', help_string='Attempt to synchronise RGB/IR streams', default=False)

    args = parser.parse_args()

    logger = logging.getLogger(__name__)

    if args.verbosity is not 'quiet':
        numeric_level = getattr(logging, args.verbosity.upper(), None)
        if not isinstance(numeric_level, int):
            raise ValueError('Invalid log level: %s' % args.verbosity)
        logging.basicConfig(level=numeric_level)
    
    output_folder = os.path.abspath(args.output)
    input_mask = args.input

    if output_folder is not "./":
        os.makedirs(output_folder, exist_ok=True)

    files = natsort.natsorted(glob.glob(input_mask))
    
    for f in files:
        logger.info("Loading: {}".format(f))
    
    splitter = flirpy.io.seq.splitter(output_folder,
                    preview_format=args.preview_format,
                    width=args.width,
                    height=args.height)
    splitter.split_filetypes = args.split_filetypes
    splitter.export_meta = args.export_meta
    splitter.export_tiff = args.export_tiff
    splitter.export_preview = args.export_preview

    if not args.skip_thermal:
        folders = splitter.process(files)
    
        if args.merge_folders:
            logger.info("Merging folders")
            for folder in tqdm(folders):
                logger.info("Copying: {}".format(folder))
                recursive_copy(folder, output_folder)
                shutil.rmtree(folder)
